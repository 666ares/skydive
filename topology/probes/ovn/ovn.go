// +build ovn

/*
 * Copyright (C) 2019 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy ofthe License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specificlanguage governing permissions and
 * limitations under the License.
 *
 */

package ovn

import (
	"context"
	"crypto/tls"
	"crypto/x509"

	"io/ioutil"
	"sync"

	"github.com/skydive-project/skydive/probe"
	"github.com/skydive-project/skydive/topology/probes"
	"github.com/skydive-project/skydive/topology/probes/ovn/ovnmodel"

	"github.com/ovn-org/libovsdb/client"
	"github.com/ovn-org/libovsdb/model"
	"github.com/ovn-org/libovsdb/ovsdb"
	"github.com/skydive-project/skydive/graffiti/graph"
	"github.com/skydive-project/skydive/graffiti/logging"
)

type ovnEvent func()

// Probe describes an OVN probe
type Probe struct {
	graph.ListenerHandler
	graph       *graph.Graph
	address     string
	certFile    string
	keyFile     string
	cacertFile  string
	ovsdb       *client.OvsdbClient
	eventChan   chan ovnEvent
	bundle      *probe.Bundle
	ifaces      *graph.MetadataIndexer
	ovnIndexers map[string]*graph.Indexer
}

var defaultOVNLikers = []ovnmodel.OVNLink{
	{
		SourceTable:  "Logical_Switch_Port",
		SourceField:  "OptionsMeta.router-port",
		DestTable:    "Logical_Router_Port",
		DestField:    "Name",
		Relationship: "layer2",
	},
}

func uuidHasher(n *graph.Node) map[string]interface{} {
	if uuid, err := n.GetFieldString("UUID"); err != nil {
		return map[string]interface{}{uuid: nil}
	}
	return nil
}

// OVNMetadata is the interface that autogenerated OVN types must satify
type OVNMetadata interface {
	GetUUID() string
	Metadata() graph.Metadata
}

// Callback to register a OVN node
func (p *Probe) registerNode(indexer *graph.Indexer, uuid string, metadata graph.Metadata) {
	logging.GetLogger().Debugf("Registering OVN object with UUID %s and metadata %+v", uuid, metadata)

	p.graph.Lock()
	defer p.graph.Unlock()

	id := graph.GenID(uuid)
	node, _ := indexer.GetNode(uuid)
	if node == nil {
		n, err := p.graph.NewNode(id, metadata)
		if err != nil {
			logging.GetLogger().Error(err)
			return
		}
		node = n
	} else {
		p.graph.SetMetadata(node, metadata)
	}

	indexer.Index(id, node, map[string]interface{}{uuid: node})
}

// Callback to unregister a OVN node
func (p *Probe) unregisterNode(indexer *graph.Indexer, uuid string) {
	logging.GetLogger().Debugf("Unregistering OVN object with UUID %s", uuid)

	p.graph.Lock()
	defer p.graph.Unlock()

	node, _ := indexer.GetNode(uuid)
	if node != nil {
		p.graph.DelNode(node)
		indexer.Unindex(node.ID, node)
	}
}

// OnError is called when an error occurred in an indexer
func (p *Probe) OnError(err error) {
	logging.GetLogger().Error(err)
}

// TODO:
// Implement Notification Handler interface
func (p *Probe) Disconnected() {
	logging.GetLogger().Warning("disconnected from the OVSDB API")
	close(p.eventChan)
}
func (p *Probe) Update(interface{}, ovsdb.TableUpdates) {}
func (p *Probe) Stolen([]interface{})                   {}
func (p *Probe) Locked([]interface{})                   {}
func (p *Probe) Echo([]interface{})                     {}

// Callback trigered when a new element was added to the OVN DB
func (p *Probe) OnAdd(table string, m model.Model) {
	logging.GetLogger().Debugf("OnAdd OVN Table %s: %v", table, m)
	meta := m.(OVNMetadata)
	indexer, ok := p.ovnIndexers[table]
	if !ok {
		return
	}
	p.eventChan <- func() { p.registerNode(indexer, meta.GetUUID(), meta.Metadata()) }
}

// Callback trigered when an element was updated in the OVN DB
func (p *Probe) OnUpdate(table string, om, nm model.Model) {
	logging.GetLogger().Debugf("OnUpdate OVN Table %s: %v", table, nm)
	meta := nm.(OVNMetadata)
	indexer, ok := p.ovnIndexers[table]
	if !ok {
		return
	}
	p.eventChan <- func() { p.registerNode(indexer, meta.GetUUID(), meta.Metadata()) }
}

// Callback trigered when an element was deleted from in the OVN DB
func (p *Probe) OnDelete(table string, om model.Model) {
	logging.GetLogger().Debugf("OnDelete OVN Table %s: %v", table, om)
	meta := om.(OVNMetadata)
	indexer, ok := p.ovnIndexers[table]
	if !ok {
		return
	}
	p.eventChan <- func() { p.unregisterNode(indexer, meta.GetUUID()) }
}

// Do implements the probe main loop
func (p *Probe) Do(ctx context.Context, wg *sync.WaitGroup) error {
	var err error

	wg.Add(1)
	go func() {
		defer func() {
			wg.Done()
			p.bundle.Stop()
		}()

		for {
			select {
			case eventCallback, ok := <-p.eventChan:
				if !ok {
					return
				}
				eventCallback()
			case <-ctx.Done():
				if p.ovsdb != nil {
					p.ovsdb.Disconnect()
				}
				return
			}
		}
	}()

	logging.GetLogger().Debugf("Trying to get an OVN DB api")

	tlsConfig := &tls.Config{}
	if p.certFile != "" && p.keyFile != "" && p.cacertFile != "" {
		cert, err := tls.LoadX509KeyPair(p.certFile, p.keyFile)
		if err != nil {
			return err
		}
		cacert, err := ioutil.ReadFile(p.cacertFile)
		if err != nil {
			return err
		}
		cacertPool := x509.NewCertPool()
		cacertPool.AppendCertsFromPEM(cacert)
		tlsConfig = &tls.Config{RootCAs: cacertPool, Certificates: []tls.Certificate{cert}}
	}

	ovnModel, err := ovnmodel.FullDatabaseModel()
	if err != nil {
		return err
	}

	p.ovsdb, err = client.Connect(context.Background(), ovnModel, client.WithEndpoint(p.address), client.WithTLSConfig(tlsConfig))
	if err != nil {
		return err
	}
	p.ovsdb.Cache.AddEventHandler(p)
	p.ovsdb.Register(p)
	logging.GetLogger().Debugf("Successfully got an OVN DB api")

	if p.ifaces != nil {
		p.graph.RLock()
		p.ifaces.Sync()
		p.graph.RUnlock()
	}

	p.bundle.Start()
	p.ovsdb.MonitorAll("")

	return nil
}

// NewProbe creates a new graph OVN database probe
func NewProbe(g *graph.Graph, address string, certFile string, keyFile string, cacertFile string) (probe.Handler, error) {
	p := &Probe{
		graph:      g,
		address:    address,
		certFile:   certFile,
		keyFile:    keyFile,
		cacertFile: cacertFile,
		eventChan:  make(chan ovnEvent, 50),
	}

	p.ovnIndexers = make(map[string]*graph.Indexer)
	dbModel, err := ovnmodel.FullDatabaseModel()
	if err != nil {
		return nil, err
	}

	for table := range dbModel.Types() {
		p.ovnIndexers[table] = graph.NewIndexer(g, nil, uuidHasher, false)
	}
	p.bundle = &probe.Bundle{
		Handlers: map[string]probe.Handler{},
	}
	for name, indexer := range p.ovnIndexers {
		p.bundle.Handlers[name+"Indexer"] = indexer
	}

	// Additional linkers
	if lspIndexer, ok := p.ovnIndexers["Logical_Switch_Port"]; ok {
		// Link Logical Switch Ports with OVS Interfaces
		p.ifaces = graph.NewMetadataIndexer(g, g, nil, "ExtID.iface-id")
		p.bundle.AddHandler("ifaces", p.ifaces)
		lspNameIndexer := graph.NewMetadataIndexer(g, lspIndexer, nil, "OVN.Name")
		p.bundle.AddHandler("FromIfaceToLogical_Switch_PortIndex", lspNameIndexer)

		ifaceLinker := graph.NewMetadataIndexerLinker(g, p.ifaces, lspNameIndexer, graph.Metadata{"RelationType": "mapping"})
		p.bundle.AddHandler("ifaceLinker", ifaceLinker)
	}

	if err := generateOVNModelLinkers(p, g); err != nil {
		return nil, err
	}
	if err := generateDefaultLinkers(p, g); err != nil {
		return nil, err
	}
	return probes.NewProbeWrapper(p), nil
}

// Registers a MetadataLinker based on a OVNLink information
func generateOVNLinker(p *Probe, g *graph.Graph, linkInfo ovnmodel.OVNLink) error {
	sourceIndexer, ok := p.ovnIndexers[linkInfo.SourceTable]
	if !ok {
		logging.GetLogger().Debugf("Skipping link from unregistered indexer %s", linkInfo.SourceTable)
		return nil
	}
	destIndexer, ok := p.ovnIndexers[linkInfo.DestTable]
	if !ok {
		logging.GetLogger().Debugf("Skipping link to unregistered indexer %s", linkInfo.DestTable)
		return nil
	}
	logging.GetLogger().Debugf("Creating indexer from %s.%s to %s.%s", linkInfo.SourceTable, linkInfo.SourceField, linkInfo.DestTable, linkInfo.DestField)

	sourceMDIndexer := graph.NewMetadataIndexer(g, sourceIndexer, nil, "OVN."+linkInfo.SourceField)
	destMDIndexer := graph.NewMetadataIndexer(g, destIndexer, nil, "OVN."+linkInfo.DestField)
	relation := linkInfo.Relationship
	if relation == "" {
		relation = "ovn"
	}
	linker := graph.NewMetadataIndexerLinker(g, sourceMDIndexer, destMDIndexer, graph.Metadata{"RelationType": relation})

	p.bundle.AddHandler(linkInfo.SourceTable+"To"+linkInfo.DestTable+"Linker", linker)
	p.bundle.AddHandler(linkInfo.SourceTable+linkInfo.SourceField+"SourceMDIndexer", sourceMDIndexer)
	p.bundle.AddHandler(linkInfo.DestTable+linkInfo.DestField+"From"+linkInfo.SourceTable+"MDIndexer", destMDIndexer)
	linker.AddEventListener(p)
	return nil
}

func generateOVNModelLinkers(p *Probe, g *graph.Graph) error {
	for _, linkInfo := range ovnmodel.GetLinks() {
		err := generateOVNLinker(p, g, linkInfo)
		if err != nil {
			return err
		}
	}
	return nil
}

func generateDefaultLinkers(p *Probe, g *graph.Graph) error {
	for _, linkInfo := range defaultOVNLikers {
		err := generateOVNLinker(p, g, linkInfo)
		if err != nil {
			return err
		}
	}
	return nil
}

// Register registers graph metadata decoders
func Register() {
	for name, decoder := range ovnmodel.Decoders() {
		logging.GetLogger().Debugf("Registering decoder for %s", name)
		graph.NodeMetadataDecoders[name] = decoder
	}
}
